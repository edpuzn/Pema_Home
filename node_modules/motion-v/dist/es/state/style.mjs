import { isCssVar, isNumber } from "./utils.mjs";
import { transformDefinitions, isTransform, transformAlias, buildTransformTemplate } from "./transform.mjs";
import { px } from "../value/types/numbers/units.mjs";
import { isMotionValue } from "../utils/motion-value.mjs";
const style = {
  get: (element, name) => {
    let value = isCssVar(name) ? element.style.getPropertyValue(name) : getComputedStyle(element)[name];
    if (!value && value !== "0") {
      const definition = transformDefinitions.get(name);
      if (definition)
        value = definition.initialValue;
    }
    return value;
  },
  set: (element, name, value) => {
    if (isCssVar(name)) {
      element.style.setProperty(name, value);
    } else {
      element.style[name] = value;
    }
  }
};
function createStyles(keyframes) {
  var _a;
  const initialKeyframes = {};
  const transforms = [];
  for (let key in keyframes) {
    let value = keyframes[key];
    value = isMotionValue(value) ? value.get() : value;
    if (isTransform(key)) {
      if (key in transformAlias) {
        key = transformAlias[key];
      }
    }
    let initialKeyframe = Array.isArray(value) ? value[0] : value;
    const definition = transformDefinitions.get(key);
    if (definition) {
      initialKeyframe = isNumber(value) ? (_a = definition.toDefaultUnit) == null ? void 0 : _a.call(definition, value) : value;
      transforms.push([key, initialKeyframe]);
    } else {
      initialKeyframes[key] = initialKeyframe;
    }
  }
  if (transforms.length) {
    initialKeyframes.transform = buildTransformTemplate(transforms);
  }
  return initialKeyframes;
}
const SVG_STYLE_TO_ATTRIBUTES = {
  fill: true,
  stroke: true,
  strokeWidth: true,
  opacity: true,
  fillOpacity: true,
  strokeOpacity: true,
  strokeLinecap: true,
  strokeLinejoin: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  cx: true,
  cy: true,
  r: true,
  d: true,
  x1: true,
  y1: true,
  x2: true,
  y2: true,
  points: true,
  pathLength: true,
  viewBox: true,
  width: true,
  height: true,
  preserveAspectRatio: true,
  clipPath: true,
  filter: true,
  mask: true,
  stopColor: true,
  stopOpacity: true,
  gradientTransform: true,
  gradientUnits: true,
  spreadMethod: true,
  markerEnd: true,
  markerMid: true,
  markerStart: true,
  textAnchor: true,
  dominantBaseline: true,
  fontFamily: true,
  fontSize: true,
  fontWeight: true,
  letterSpacing: true,
  vectorEffect: true
};
function buildSVGPath(attrs, length, spacing = 1, offset = 0) {
  attrs.pathLength = 1;
  attrs["stroke-dashoffset"] = px.transform(-offset);
  const pathLength = px.transform(length);
  const pathSpacing = px.transform(spacing);
  attrs["stroke-dasharray"] = `${pathLength} ${pathSpacing}`;
}
function convertSvgStyleToAttributes(keyframes) {
  const attributes = {};
  const styleProps = {};
  for (const key in keyframes) {
    if (key in SVG_STYLE_TO_ATTRIBUTES) {
      const value = keyframes[key];
      attributes[key] = isMotionValue(value) ? value.get() : value;
    } else {
      styleProps[key] = keyframes[key];
    }
  }
  if (attributes.pathLength) {
    buildSVGPath(attributes, attributes.pathLength, attributes.pathSpacing, attributes.pathOffset);
  }
  return {
    attributes,
    style: styleProps
  };
}
export {
  convertSvgStyleToAttributes,
  createStyles,
  style
};
